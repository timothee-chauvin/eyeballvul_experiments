{
  "commit": "3ad12658bb91c5f6fb7d36e43d70ed7be0803354",
  "repo_url": "https://github.com/jenkinsci/backlog-plugin",
  "model": "gemini/gemini-1.5-pro",
  "chunk_hashes": [
    "c149f6299a1da05009de"
  ],
  "responses": [
    {
      "content": "```yaml\nleads:\n  - headline: Backlog API Key stored in Jenkins\n    analysis: |\n      The Backlog API Key is stored in plain text within the Jenkins configuration for the Backlog plugin. \n      This means that anyone with access to the Jenkins configuration files, or who has administrative access to the Jenkins instance, \n      can obtain the API Key and use it to access the Backlog account.\n    cwe: CWE-252\n    function_names:\n      - BacklogProjectProperty\n      - BacklogPullRequestSCMSource\n    filenames:\n      - src/main/java/hudson/plugins/backlog/BacklogProjectProperty.java\n      - src/main/java/hudson/plugins/backlog/pipeline/BacklogPullRequestSCMSource.java\n    classification: very promising\n```\n<><><>codebase<><><>\n<><><>Fraction of the full repository included below: 11.1%<><><>\n<><><>CONTENTS OF src/main/java/hudson/plugins/backlog/BacklogProjectProperty.java:<><><>\npackage hudson.plugins.backlog;\n\nimport hudson.Extension;\nimport hudson.model.Action;\nimport hudson.model.JobProperty;\nimport hudson.model.JobPropertyDescriptor;\nimport hudson.model.AbstractProject;\nimport hudson.model.Job;\nimport hudson.util.FormValidation;\nimport hudson.util.Secret;\nimport jenkins.branch.MultiBranchProject;\nimport jenkins.model.ParameterizedJobMixIn;\nimport jenkins.model.TransientActionFactory;\nimport net.sf.json.JSONObject;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.jenkinsci.plugins.workflow.job.WorkflowJob;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.StaplerRequest;\n\nimport javax.annotation.Nonnull;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Collection;\nimport java.util.Collections;\n\n/**\n * Property for {@link AbstractProject} that stores the associated Backlog\n * website URL.\n * \n * @see <a href=\"http://d.hatena.ne.jp/cactusman/20090328/p1\">http://d.hatena.ne.jp/cactusman/20090328/p1</a>\n * @author dragon3\n */\npublic final class BacklogProjectProperty extends\n\t\tJobProperty<Job<?, ?>> {\n\n\tpublic final String url;\n\tpublic final String userId;\n\tprivate final Secret password;\n\tprivate final Secret apiKey;\n\n\t@DataBoundConstructor\n\tpublic BacklogProjectProperty(final String url, final String userId,\n\t\t\t\t\t\t\t\t  final String password, final String apiKey) {\n\n\t\t// normalize\n\t\tif (StringUtils.isNotEmpty(url)) {\n\t\t\tif (url.contains(\"/projects/\")) {\n\t\t\t\tthis.url = url;\n\t\t\t} else if (url.endsWith(\"/\")) {\n\t\t\t\tthis.url = url;\n\t\t\t} else {\n\t\t\t\tthis.url = url + '/';\n\t\t\t}\n\t\t} else {\n\t\t\tthis.url = null;\n\t\t}\n\n\t\tthis.userId = userId;\n\t\tthis.password = Secret.fromString(password);\n\t\tthis.apiKey = Secret.fromString(apiKey);\n\t}\n\n\tpublic String getPassword() {\n\t\treturn Secret.toString(password);\n\t}\n\n\tpublic String getApiKey() {\n\t\treturn Secret.toString(apiKey);\n\t}\n\n\tpublic String getSpaceURL() {\n\t\tif (url == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (url.contains(\"/projects/\")) {\n\t\t\treturn url.substring(0, url.indexOf(\"/projects/\") + 1);\n\t\t} else {\n\t\t\treturn url;\n\t\t}\n\n\t}\n\n\tpublic String getProject() {\n\t\tif (url == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!url.contains(\"/projects/\")) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn url.substring(url.indexOf(\"/projects/\") + \"/projects/\".length());\n\t}\n\n\t@Override\n\tpublic Action getJobAction(Job<?, ?> job) {\n\t\treturn new BacklogLinkAction(this);\n\t}\n\n\t@Extension\n\tpublic static final class DescriptorImpl extends JobPropertyDescriptor {\n\n\t\tpublic DescriptorImpl() {\n\t\t\tsuper(BacklogProjectProperty.class);\n\t\t\tload();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isApplicable(Class<? extends Job> jobType) {\n\t\t\treturn ParameterizedJobMixIn.ParameterizedJob.class.isAssignableFrom(jobType);\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDisplayName() {\n\t\t\treturn Messages.BacklogProjectProperty_DisplayName();\n\t\t}\n\n\t\tpublic FormValidation doCheckUrl(@QueryParameter String url) {\n\t\t\ttry {\n\t\t\t\tnew URL(url);\n\t\t\t} catch (MalformedURLException e) {\n\t\t\t\treturn FormValidation.error(Messages\n\t\t\t\t\t\t.BacklogSecurityRealm_Url_Error());\n\t\t\t}\n\n\t\t\treturn FormValidation.ok();\n\t\t}\n\n\t\tpublic FormValidation doCheckUserId(@QueryParameter String userId) {\n\t\t\tif (StringUtils.isEmpty(userId) || userId.matches(\"[A-Za-z0-9-_@.]+\")) {\n\t\t\t\treturn FormValidation.ok();\n\t\t\t} else {\n\t\t\t\treturn FormValidation.error(Messages\n\t\t\t\t\t\t.BacklogProjectProperty_UserId_Error());\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic JobProperty<?> newInstance(StaplerRequest req,\n\t\t\t\tJSONObject formData) throws FormException {\n\n\t\t\tif (formData.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tBacklogProjectProperty bpp = req.bindJSON(\n\t\t\t\t\tBacklogProjectProperty.class,\n\t\t\t\t\tformData.getJSONObject(\"backlog\"));\n\t\t\treturn bpp;\n\t\t}\n\t}\n\n\t@Extension\n\tpublic static class Factory extends TransientActionFactory<WorkflowJob> {\n\n\t\t@Override\n\t\tpublic Class<WorkflowJob> type() {\n\t\t\treturn WorkflowJob.class;\n\t\t}\n\n\t\t@Nonnull\n\t\t@Override\n\t\tpublic Collection<? extends Action> createFor(@Nonnull WorkflowJob target) {\n\t\t\tif (target.getParent() instanceof MultiBranchProject) {\n\t\t\t\t// Instead, add BacklogPullRequestLinkAction in BacklogPullRequestBranchProperty\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\n\t\t\treturn Collections.singleton(new BacklogLinkAction(target.getProperty(BacklogProjectProperty.class)));\n\t\t}\n\t}\n\n}\n\n<><><>CONTENTS OF src/main/java/hudson/plugins/backlog/pipeline/BacklogPullRequestSCMSource.java:<><><>\npackage hudson.plugins.backlog.pipeline;\n\nimport com.cloudbees.plugins.credentials.CredentialsProvider;\nimport com.cloudbees.plugins.credentials.common.StandardListBoxModel;\nimport com.cloudbees.plugins.credentials.common.StandardUsernameCredentials;\nimport com.cloudbees.plugins.credentials.domains.URIRequirementBuilder;\nimport com.nulabinc.backlog4j.PullRequest;\nimport com.nulabinc.backlog4j.ResponseList;\nimport com.nulabinc.backlog4j.api.option.PullRequestQueryParams;\nimport edu.umd.cs.findbugs.annotations.CheckForNull;\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n\nimport edu.umd.cs.findbugs.annotations.NonNull;\nimport hudson.EnvVars;\nimport hudson.Extension;\nimport hudson.Util;\nimport hudson.model.*;\nimport hudson.model.queue.Tasks;\nimport hudson.plugins.backlog.BacklogProjectProperty;\nimport hudson.plugins.backlog.Messages;\nimport hudson.plugins.backlog.api.v2.BacklogClientFactory;\nimport hudson.plugins.git.Branch;\nimport hudson.plugins.git.GitStatus;\nimport hudson.plugins.git.GitSCM;\nimport hudson.plugins.git.GitTool;\nimport hudson.plugins.git.browser.GitRepositoryBrowser;\nimport hudson.plugins.git.extensions.GitSCMExtensionDescriptor;\nimport hudson.plugins.git.extensions.GitSCMExtension;\nimport hudson.scm.RepositoryBrowser;\nimport hudson.scm.SCM;\nimport hudson.security.ACL;\nimport hudson.util.FormValidation;\nimport hudson.util.ListBoxModel;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Map;\n\nimport hudson.util.Secret;\nimport jenkins.model.Jenkins;\n\nimport jenkins.plugins.git.AbstractGitSCMSource;\nimport jenkins.scm.api.*;\nimport org.acegisecurity.context.SecurityContext;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.apache.commons.lang.StringUtils;\n\nimport org.eclipse.jgit.lib.FileMode;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevTree;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.transport.RefSpec;\nimport org.eclipse.jgit.transport.URIish;\nimport org.eclipse.jgit.treewalk.TreeWalk;\nimport org.jenkinsci.plugins.gitclient.FetchCommand;\nimport org.jenkinsci.plugins.gitclient.Git;\nimport org.jenkinsci.plugins.gitclient.GitClient;\nimport org.kohsuke.stapler.AncestorInPath;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.DataBoundSetter;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\n\nimport java.io.PrintWriter;\nimport java.net.URISyntaxException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Lock;\nimport java.util.logging.Logger;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\n\n/**\n * Customize GitSCMSource to fit Backlog Git ( from git-plugin v3.0.4 )\n *\n * @see <a href=\"https://github.com/jenkinsci/git-plugin/blob/git-3.0.4/src/main/java/jenkins/plugins/git/AbstractGitSCMSource.java\">AbstractGitSCMSource.java</a>\n * @see <a href=\"https://github.com/jenkinsci/git-plugin/blob/git-3.0.4/src/main/java/jenkins/plugins/git/GitSCMSource.java\">GitSCMSource.java</a>\n * @author ikikko\n */\npublic class BacklogPullRequestSCMSource extends AbstractGitSCMSource {\n\n    // --- Copy from GitSCMSource.java ---\n\n    private static final String DEFAULT_INCLUDES = \"*\";\n\n    private static final String DEFAULT_EXCLUDES = \"\";\n\n    public static final Logger LOGGER = Logger.getLogger(BacklogPullRequestSCMSource.class.getName());\n\n    private final String remote;\n\n    private final String credentialsId;\n\n    private final String includes;\n\n    private final String excludes;\n\n    private final boolean ignoreOnPushNotifications;\n\n    private final String url;\n\n    private final Secret apiKey;\n\n    private final BacklogProjectProperty bpp;\n\n    @CheckForNull\n    private GitRepositoryBrowser browser;\n\n    @CheckForNull\n    private String gitTool;\n\n    private List<GitSCMExtension> extensions;\n\n    @DataBoundConstructor\n    public BacklogPullRequestSCMSource(String id, String remote, String credentialsId, String includes, String excludes, boolean ignoreOnPushNotifications,\n                                       String url, String apiKey) {\n        super(id);\n        this.remote = remote;\n        this.credentialsId = credentialsId;\n        this.includes = includes;\n        this.excludes = excludes;\n        this.ignoreOnPushNotifications = ignoreOnPushNotifications;\n\n        this.url = url;\n        this.apiKey = Secret.fromString(apiKey);\n\n        this.bpp = new BacklogProjectProperty(url, \"\", \"\", apiKey);\n    }\n\n    public boolean isIgnoreOnPushNotifications() {\n      return ignoreOnPushNotifications;\n    }\n\n    @Override\n    public GitRepositoryBrowser getBrowser() {\n        return browser;\n    }\n\n    // For Stapler only\n    @Restricted(NoExternalUse.class)\n    @DataBoundSetter\n    public void setBrowser(GitRepositoryBrowser browser) {\n        this.browser = browser;\n    }\n\n    @Override\n    public String getGitTool() {\n        return gitTool;\n    }\n\n    // For Stapler only\n    @Restricted(NoExternalUse.class)\n    @DataBoundSetter\n    public void setGitTool(String gitTool) {\n        this.gitTool = Util.fixEmptyAndTrim(gitTool);\n    }\n\n    @Override\n    public List<GitSCMExtension> getExtensions() {\n        if (extensions == null) {\n            return Collections.emptyList();\n        }\n        return Collections.unmodifiableList(new ArrayList<GitSCMExtension>(extensions));\n    }\n\n    // For Stapler only\n    @Restricted(NoExternalUse.class)\n    @DataBoundSetter\n    public void setExtensions(List<GitSCMExtension> extensions) {\n        this.extensions = Util.fixNull(extensions);\n    }\n\n    @Override\n    public String getCredentialsId() {\n        return credentialsId;\n    }\n\n    public String getRemote() {\n        return remote;\n    }\n\n    @Override\n    public String getIncludes() {\n        return includes;\n    }\n\n    @Override\n    public String getExcludes() {\n        return excludes;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    public Secret getApiKey() {\n        return apiKey;\n    }\n\n    public BacklogProjectProperty getBpp() {\n        return bpp;\n    }\n\n    @Override\n    protected List<RefSpec> getRefSpecs() {\n        // Change for pull request branches\n        return Arrays.asList(new RefSpec(\"+refs/pull/*:refs/remotes/\" + getRemoteName() + \"/*\"));\n    }\n\n    @Extension\n    public static class DescriptorImpl extends SCMSourceDescriptor {\n\n        @Override\n        public String getDisplayName() {\n            return Messages.BacklogPullRequestSCMSource_DisplayName();\n        }\n\n        @SuppressFBWarnings(value=\"NP_NULL_PARAM_DEREF\", justification=\"pending https://github.com/jenkinsci/credentials-plugin/pull/68\")\n        public ListBoxModel doFillCredentialsIdItems(@AncestorInPath SCMSourceOwner context,\n                                                     @QueryParameter String remote,\n                                                     @QueryParameter String credentialsId) {\n            if (context == null && !Jenkins.getActiveInstance().hasPermission(Jenkins.ADMINISTER) ||\n                context != null && !context.hasPermission(Item.EXTENDED_READ)) {\n                return new StandardListBoxModel().includeCurrentValue(credentialsId);\n            }\n            return new StandardListBoxModel()\n                    .includeEmptyValue()\n                    .includeMatchingAs(\n                            context instanceof Queue.Task ? Tasks.getAuthenticationOf((Queue.Task)context) : ACL.SYSTEM,\n                            context,\n                            StandardUsernameCredentials.class,\n                            URIRequirementBuilder.fromUri(remote).build(),\n                            GitClient.CREDENTIALS_MATCHER)\n                    .includeCurrentValue(credentialsId);\n        }\n\n        public FormValidation doCheckCredentialsId(@AncestorInPath SCMSourceOwner context,\n                                                   @QueryParameter String url,\n                                                   @QueryParameter String value) {\n            if (context == null && !Jenkins.getActiveInstance().hasPermission(Jenkins.ADMINISTER) ||\n                context != null && !context.hasPermission(Item.EXTENDED_READ)) {\n                return FormValidation.ok();\n            }\n\n            value = Util.fixEmptyAndTrim(value);\n            if (value == null) {\n                return FormValidation.ok();\n            }\n\n            url = Util.fixEmptyAndTrim(url);\n            if (url == null)\n            // not set, can't check\n            {\n                return FormValidation.ok();\n            }\n\n            for (ListBoxModel.Option o : CredentialsProvider.listCredentials(\n                    StandardUsernameCredentials.class,\n                    context,\n                    context instanceof Queue.Task\n                            ? Tasks.getAuthenticationOf((Queue.Task) context)\n                            : ACL.SYSTEM,\n                    URIRequirementBuilder.fromUri(url).build(),\n                    GitClient.CREDENTIALS_MATCHER)) {\n                if (StringUtils.equals(value, o.value)) {\n                    // TODO check if this type of credential is acceptable to the Git client or does it merit warning\n                    // NOTE: we would need to actually lookup the credential to do the check, which may require\n                    // fetching the actual credential instance from a remote credentials store. Perhaps this is\n                    // not required\n                    return FormValidation.ok();\n                }\n            }\n            // no credentials available, can't check\n            return FormValidation.warning(\"Cannot find any credentials with id \" + value);\n        }\n\n        public GitSCM.DescriptorImpl getSCMDescriptor() {\n            return (GitSCM.DescriptorImpl)Jenkins.getInstance().getDescriptor(GitSCM.class);\n        }\n\n        public List<GitSCMExtensionDescriptor> getExtensionDescriptors() {\n            return getSCMDescriptor().getExtensionDescriptors();\n        }\n\n        public List<Descriptor<RepositoryBrowser<?>>> getBrowserDescriptors() {\n            return getSCMDescriptor().getBrowserDescriptors();\n        }\n\n        public boolean showGitToolOptions() {\n            return getSCMDescriptor().showGitToolOptions();\n        }\n\n        public ListBoxModel doFillGitToolItems() {\n            return getSCMDescriptor().doFillGitToolItems();\n        }\n    }\n\n    @Extension\n    public static class ListenerImpl extends GitStatus.Listener {\n\n        @Override\n        public List<GitStatus.ResponseContributor> onNotifyCommit(URIish uri, final String sha1, List<ParameterValue> buildParameters, String... branches) {\n            List<GitStatus.ResponseContributor> result = new ArrayList<GitStatus.ResponseContributor>();\n            final boolean notified[] = {false};\n            // run in high privilege to see all the projects anonymous users don't see.\n            // this is safe because when we actually schedule a build, it's a build that can\n            // happen at some random time anyway.\n            Jenkins jenkins = Jenkins.getInstance();\n            if (jenkins == null) {\n                LOGGER.severe(\"Jenkins instance is null in BacklogPullRequestSCMSource.onNotifyCommit\");\n                return result;\n            }\n            SecurityContext old = jenkins.getACL().impersonate(ACL.SYSTEM);\n            try {\n                if (branches.length > 0) {\n                    final URIish u = uri;\n                    for (final String branch: branches) {\n                        SCMHeadEvent.fireNow(new SCMHeadEvent<String>(SCMEvent.Type.UPDATED, branch){\n                            @Override\n                            public boolean isMatch(@NonNull SCMNavigator navigator) {\n                                return false;\n                            }\n\n                            @NonNull\n                            @Override\n                            public String getSourceName() {\n                                // we will never be called here as do not match any navigator\n                                return u.getHumanishName();\n                            }\n\n                            @Override\n                            public boolean isMatch(SCMSource source) {\n                                if (source instanceof BacklogPullRequestSCMSource) {\n                                    BacklogPullRequestSCMSource git = (BacklogPullRequestSCMSource) source;\n                                    if (git.ignoreOnPushNotifications) {\n                                        return false;\n                                    }\n                                    URIish remote;\n                                    try {\n                                        remote = new URIish(git.getRemote());\n                                    } catch (URISyntaxException e) {\n                                        // ignore\n                                        return false;\n                                    }\n                                    if (GitStatus.looselyMatches(u, remote)) {\n                                        notified[0] = true;\n                                        return true;\n                                    }\n                                    return false;\n                                }\n                                return false;\n                            }\n\n                            @NonNull\n                            @Override\n                            public Map<SCMHead, SCMRevision> heads(@NonNull SCMSource source) {\n                                SCMHead head = new SCMHead(branch);\n                                return Collections.<SCMHead, SCMRevision>singletonMap(head,\n                                        sha1 != null ? new SCMRevisionImpl(head, sha1) : null);\n                            }\n\n                            @Override\n                            public boolean isMatch(@NonNull SCM scm) {\n                                return false; // TODO rewrite the legacy event system to fire through SCM API\n                            }\n                        });\n                    }\n                } else {\n                    for (final SCMSourceOwner owner : SCMSourceOwners.all()) {\n                        for (SCMSource source : owner.getSCMSources()) {\n                            if (source instanceof BacklogPullRequestSCMSource) {\n                                BacklogPullRequestSCMSource git = (BacklogPullRequestSCMSource) source;\n                                if (git.ignoreOnPushNotifications) {\n                                    continue;\n                                }\n                                URIish remote;\n                                try {\n                                    remote = new URIish(git.getRemote());\n                                } catch (URISyntaxException e) {\n                                    // ignore\n                                    continue;\n                                }\n                                if (GitStatus.looselyMatches(uri, remote)) {\n                                    LOGGER.info(\"Triggering the indexing of \" + owner.getFullDisplayName());\n                                    owner.onSCMSourceUpdated(source);\n                                    result.add(new GitStatus.ResponseContributor() {\n                                        @Override\n                                        public void addHeaders(StaplerRequest req, StaplerResponse rsp) {\n                                            rsp.addHeader(\"Triggered\", owner.getAbsoluteUrl());\n                                        }\n\n                                        @Override\n                                        public void writeBody(PrintWriter w) {\n                                            w.println(\"Scheduled indexing of \" + owner.getFullDisplayName());\n                                        }\n                                    });\n                                    notified[0] = true;\n                                }\n                            }\n                        }\n                    }\n                }\n            } finally {\n                SecurityContextHolder.setContext(old);\n            }\n            if (!notified[0]) {\n                result.add(new GitStatus.MessageResponseContributor(\"No Git consumers using SCM API plugin for: \" + uri.toString()));\n            }\n            return result;\n        }\n    }\n\n    // --- Copy from AbstractGitSCMSource.java  ---\n\n    @CheckForNull\n    @Override\n    protected SCMRevision retrieve(@NonNull final SCMHead head, @NonNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return doRetrieve(new Retriever<SCMRevision>() {\n            @Override\n            public SCMRevision run(GitClient client, String remoteName) throws IOException, InterruptedException {\n                for (Branch b : client.getRemoteBranches()) {\n                    // Change for pull request branches\n                    // String branchName = StringUtils.removeStart(b.getName(), remoteName + \"/\");\n                    String branchName = StringUtils.removeEnd(StringUtils.removeStart(b.getName(), remoteName + \"/\"), \"/head\");\n                    if (branchName.equals(head.getName())) {\n                        return new SCMRevisionImpl(head, b.getSHA1String());\n                    }\n                }\n                return null;\n            }\n        }, listener, /* we don't prune remotes here, as we just want one head's revision */false);\n    }\n\n    @Override\n    protected void retrieve(@CheckForNull final SCMSourceCriteria criteria,\n                            @NonNull final SCMHeadObserver observer,\n                            @CheckForNull final SCMHeadEvent<?> event,\n                            @NonNull final TaskListener listener)\n            throws IOException, InterruptedException {\n        doRetrieve(new Retriever<Void>() {\n            @Override\n            public Void run(GitClient client, String remoteName) throws IOException, InterruptedException {\n                final Repository repository = client.getRepository();\n                listener.getLogger().println(\"Getting remote branches...\");\n                // Change for pull request branches\n                ResponseList<PullRequest> pullRequests = getOpenPullRequests();\n                try (RevWalk walk = new RevWalk(repository)) {\n                    walk.setRetainBody(false);\n                    for (Branch b : client.getRemoteBranches()) {\n                        checkInterrupt();\n                        if (!b.getName().startsWith(remoteName + \"/\")) {\n                            continue;\n                        }\n                        // Change for pull request branches\n                        // final String branchName = StringUtils.removeStart(b.getName(), remoteName + \"/\");\n                        final String branchName = StringUtils.removeEnd(StringUtils.removeStart(b.getName(), remoteName + \"/\"), \"/head\");\n                        listener.getLogger().println(\"Checking branch \" + branchName);\n                        if (isExcluded(branchName)){\n                            continue;\n                        }\n                        // Change for pull request branches\n                        if (!isPullRequestOpen(pullRequests, branchName)) {\n                            continue;\n                        }\n                        if (criteria != null) {\n                            RevCommit commit = walk.parseCommit(b.getSHA1());\n                            final long lastModified = TimeUnit.SECONDS.toMillis(commit.getCommitTime());\n                            final RevTree tree = commit.getTree();\n                            SCMSourceCriteria.Probe probe = new SCMProbe() {\n                                @Override\n                                public void close() throws IOException {\n                                    // no-op\n                                }\n\n                                @Override\n                                public String name() {\n                                    return branchName;\n                                }\n\n                                @Override\n                                public long lastModified() {\n                                    return lastModified;\n                                }\n\n                                @Override\n                                @NonNull\n                                @SuppressFBWarnings(value = \"NP_LOAD_OF_KNOWN_NULL_VALUE\",\n                                                    justification = \"TreeWalk.forPath can return null, compiler \"\n                                                            + \"generated code for try with resources handles it\")\n                                public SCMProbeStat stat(@NonNull String path) throws IOException {\n                                    try (TreeWalk tw = TreeWalk.forPath(repository, path, tree)) {\n                                        if (tw == null) {\n                                            return SCMProbeStat.fromType(SCMFile.Type.NONEXISTENT);\n                                        }\n                                        FileMode fileMode = tw.getFileMode(0);\n                                        if (fileMode == FileMode.MISSING) {\n                                            return SCMProbeStat.fromType(SCMFile.Type.NONEXISTENT);\n                                        }\n                                        if (fileMode == FileMode.EXECUTABLE_FILE) {\n                                            return SCMProbeStat.fromType(SCMFile.Type.REGULAR_FILE);\n                                        }\n                                        if (fileMode == FileMode.REGULAR_FILE) {\n                                            return SCMProbeStat.fromType(SCMFile.Type.REGULAR_FILE);\n                                        }\n                                        if (fileMode == FileMode.SYMLINK) {\n                                            return SCMProbeStat.fromType(SCMFile.Type.LINK);\n                                        }\n                                        if (fileMode == FileMode.TREE) {\n                                            return SCMProbeStat.fromType(SCMFile.Type.DIRECTORY);\n                                        }\n                                        return SCMProbeStat.fromType(SCMFile.Type.OTHER);\n                                    }\n                                }\n                            };\n                            if (criteria.isHead(probe, listener)) {\n                                listener.getLogger().println(\"Met criteria\");\n                            } else {\n                                listener.getLogger().println(\"Does not meet criteria\");\n                                continue;\n                            }\n                        }\n                        SCMHead head = new SCMHead(branchName);\n                        SCMRevision hash = new SCMRevisionImpl(head, b.getSHA1String());\n                        observer.observe(head, hash);\n                        if (!observer.isObserving()) {\n                            return null;\n                        }\n                    }\n                }\n\n                listener.getLogger().println(\"Done.\");\n                return null;\n            }\n        }, listener, true);\n    }\n\n    private interface Retriever<T> {\n        T run(GitClient client, String remoteName) throws IOException, InterruptedException;\n    }\n\n    private <T> T doRetrieve(BacklogPullRequestSCMSource.Retriever<T> retriever, @NonNull TaskListener listener, boolean prune)\n            throws IOException, InterruptedException {\n        String cacheEntry = getCacheEntry();\n        Lock cacheLock = getCacheLock(cacheEntry);\n        cacheLock.lock();\n        try {\n            File cacheDir = getCacheDir(cacheEntry);\n            Git git = Git.with(listener, new EnvVars(EnvVars.masterEnvVars)).in(cacheDir);\n            GitTool tool = resolveGitTool();\n            if (tool != null) {\n                git.using(tool.getGitExe());\n            }\n            GitClient client = git.getClient();\n            client.addDefaultCredentials(getCredentials());\n            if (!client.hasGitRepo()) {\n                listener.getLogger().println(\"Creating git repository in \" + cacheDir);\n                client.init();\n            }\n            String remoteName = getRemoteName();\n            listener.getLogger().println(\"Setting \" + remoteName + \" to \" + getRemote());\n            client.setRemoteUrl(remoteName, getRemote());\n            listener.getLogger().println((prune ? \"Fetching & pruning \" : \"Fetching \") + remoteName + \"...\");\n            FetchCommand fetch = client.fetch_();\n            if (prune) {\n                fetch = fetch.prune();\n            }\n            URIish remoteURI = null;\n            try {\n                remoteURI = new URIish(remoteName);\n            } catch (URISyntaxException ex) {\n                listener.getLogger().println(\"URI syntax exception for '\" + remoteName + \"' \" + ex);\n            }\n            fetch.from(remoteURI, getRefSpecs()).execute();\n            return retriever.run(client, remoteName);\n        } finally {\n            cacheLock.unlock();\n        }\n    }\n\n    private ResponseList<PullRequest> getOpenPullRequests() throws MalformedURLException {\n        PullRequestQueryParams params = new PullRequestQueryParams();\n        params.statusType(Collections.singletonList(PullRequest.StatusType.Open));\n        params.count(100); // max count\n\n        String repoName = new URIish(new URL(remote)).getHumanishName();\n        return BacklogClientFactory.getBacklogClient(bpp).getPullRequests(bpp.getProject(), repoName, params);\n    }\n\n    private boolean isPullRequestOpen(ResponseList<PullRequest> pullRequests, String branchName) {\n        for (PullRequest pullRequest : pullRequests) {\n            if (pullRequest.getNumber() == Long.parseLong(branchName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n\n```",
      "date": "2024-06-14T14:07:43.617785",
      "usage": {
        "prompt_tokens": 27490,
        "completion_tokens": 5866,
        "cost": 0.028180000000000004
      }
    }
  ],
  "leads": [
    {
      "headline": "Backlog API Key stored in Jenkins",
      "analysis": "The Backlog API Key is stored in plain text within the Jenkins configuration for the Backlog plugin. \nThis means that anyone with access to the Jenkins configuration files, or who has administrative access to the Jenkins instance, \ncan obtain the API Key and use it to access the Backlog account.\n",
      "classification": "very promising",
      "cwe": "CWE-252",
      "function_names": [
        "BacklogProjectProperty",
        "BacklogPullRequestSCMSource"
      ],
      "filenames": [
        "src/main/java/hudson/plugins/backlog/BacklogProjectProperty.java",
        "src/main/java/hudson/plugins/backlog/pipeline/BacklogPullRequestSCMSource.java"
      ]
    }
  ],
  "scores": [
    {
      "stats": {
        "fn": 0,
        "tp": 1,
        "fp": 0
      },
      "mapping": {
        "0": "CVE-2020-2153"
      },
      "vuln_dates": {
        "CVE-2020-2153": "2020-03-09T16:15:14"
      },
      "scoring_model": "claude-3-opus-20240229",
      "type": "llm",
      "instruction_template_hash": "245ace12b6361954d0a2"
    }
  ],
  "instruction_template_hash": "10c0163db4740318a544",
  "version": "0.1.0"
}
