{
  "commit": "d17da850f1c0083de65e458937b8c6b2fbddaa3b",
  "repo_url": "https://github.com/mikebrady/nqptp",
  "model": "gemini/gemini-1.5-pro",
  "chunk_hashes": [
    "27a9fb8e6703eeab5e4d"
  ],
  "responses": [
    {
      "content": "```yaml\nleads:\n  - headline: Potential race condition in handling of shared memory\n    analysis: |\n      The code uses a shared memory interface to communicate between the main thread and a broadcasting task. However, there is no explicit synchronization mechanism to protect access to the shared memory during the execution of timed tasks. This could lead to a race condition if a timed task and the main thread try to access or modify the shared memory simultaneously. For example, the broadcasting task might read an inconsistent state if the main thread is in the middle of updating it.\n\n      An attacker could potentially exploit this race condition by sending a carefully timed sequence of PTP messages and control port messages, causing the broadcasting task to read incorrect clock information. This could lead to denial of service if the incorrect information disrupts the synchronization of the PTP clocks.\n    cwe: CWE-362\n    function_names:\n      - broadcasting_task\n      - handle_control_port_messages\n    filenames:\n      - nqptp.c\n      - nqptp-clock-sources.c\n    classification: slightly promising\n```<><><>codebase<><><>\n<><><>Fraction of the full repository included below: 100.0%<><><>\n<><><>CONTENTS OF nqptp.h:<><><>\n/*\n * This file is part of the nqptp distribution (https://github.com/mikebrady/nqptp).\n * Copyright (c) 2021-2022 Mike Brady.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n * Commercial licensing is also available.\n */\n\n#ifndef NQPTP_H\n#define NQPTP_H\n\n#include <inttypes.h>\n#include <pthread.h>\n\n#include \"nqptp-shm-structures.h\"\n\n#define MAX_CLOCKS 64\n#define MAX_CLIENTS 16\n#define MAX_OPEN_SOCKETS 16\n\n// When a new timing peer group is created, one of the clocks in the\n// group may become the master and its native time becomes the \"master time\".\n// This is what is provided to the client.\n\n// An NQPTP client interface communicates through a shared memory interface named by the\n// shm_interface_name It provides the shm_interface_name at the start of every control message it\n// sends through port 9000. Following the name, the client can specify the members -- the \"PTP\n// Instances\" -- of a \"PTP Network\" it wishes to monitor. This is a \"timing group\" in AirPlay 2\n// parlance, it seems.\n\nvoid send_awakening_announcement_sequence(const uint64_t clock_id, const char *clock_ip,\n                                          const int ip_family, const uint8_t priority1,\n                                          const uint8_t priority2);\n\n#endif\n\n<><><>CONTENTS OF nqptp-ptp-definitions.h:<><><>\n/*\n * This file is part of the nqptp distribution (https://github.com/mikebrady/nqptp).\n * Copyright (c) 2021-2022 Mike Brady.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n * Commercial licensing is also available.\n */\n\n#ifndef NQPTP_PTP_DEFINITIONS_H\n#define NQPTP_PTP_DEFINITIONS_H\n\n#include <inttypes.h>\n\n// This is for definitions and stuff that flows more or less directly\n// from external sources.\n\n// They may not be used. Yet.\n\n// Derived from\n// https://github.com/rroussel/OpenAvnu/blob/ArtAndLogic-aPTP-changes/daemons/gptp/gptp_cfg.ini:\n\n#define aPTPpriority1 248\n#define aPTPpriority2 248\n#define aPTPaccuracy 254\n\n// \"Per the Apple Vendor PTP profile\"\n// these seem to be log2 of seconds, thus 0 is 2^0 or 1 sec, -3 to 2^-3 or 0.125 sec\n// see 7.7.7.2\n#define aPTPinitialLogAnnounceInterval 0\n\n// see 7.7.2.3\n#define aPTPinitialLogSyncInterval -3\n\n// This doesn't seem to be used in OpenAvnu\n// but see 7.7.3.1, so it looks like they are units of the announceInterval, so seconds here\n#define aPTPannounceReceiptTimeout 120\n\n// \"Per the Apple Vendor PTP profile (8*announceReceiptTimeout)\"\n// This doesn't seem to be used in OpenAvnu\n// Guess it's the same idea, but based on aPTPinitialLogSyncInterval\n// but it could be based on aPTPinitialLogAnnounceInterval, of course.\n\n#define aPTPsyncReceiptTimeout 960\n\n// \"Neighbor propagation delay threshold in nanoseconds\"\n#define aPTPneighborPropDelayThresh 800\n\n// \"Sync Receipt Threshold\n// This value defines the number of syncs with wrong seqID that will trigger\n// the ptp slave to become master (it will start announcing)\n// Normally sync messages are sent every 125ms, so setting it to 8 will allow\n// up to 1 second of wrong messages before switching\"\n\n#define aPTPsyncReceiptThresh 8\n\n// References from the IEEE Document ISBN 978-0-7381-5400-8 STD95773.\n// \"IEEE Standard for a Precision Clock Synchronization Protocol for Networked Measurement and\n// Control Systems\" The IEEE Std 1588-2008 (Revision of IEEE Std 1588-2002)\n\n// See 9.3.2.4.4 FOREIGN_MASTER_TIME_WINDOW and FOREIGN_MASTER_THRESHOLD\n// units are the announceInterval\n#define FOREIGN_MASTER_TIME_WINDOW 4\n#define FOREIGN_MASTER_THRESHOLD 2\n\n// See also 9.3.2.5 Qualification of Announce messages\n\n// Table 19\nenum messageType {\n  Sync,\n  Delay_Req,\n  Pdelay_Req,\n  Pdelay_Resp,\n  Reserved_4,\n  Reserved_5,\n  Reserved_6,\n  Reserved_7,\n  Follow_Up,\n  Delay_Resp,\n  Pdelay_Resp_Follow_Up,\n  Announce,\n  Signaling,\n  Management,\n  Reserved_E,\n  Reserved_F\n};\n\n// Table 34, part of\nenum tlvTypeValue {\n  Reserved,\n  // Standard TLVs\n  MANAGEMENT,\n  MANAGEMENT_ERROR_STATUS,\n  ORGANIZATION_EXTENSION,\n  // Optional unicast message negotiation TLVs\n  REQUEST_UNICAST_TRANSMISSION,\n  GRANT_UNICAST_TRANSMISSION,\n  CANCEL_UNICAST_TRANSMISSION,\n  ACKNOWLEDGE_CANCEL_UNICAST_TRANSMISSION,\n  // Optional path trace mechanism TLV\n  PATH_TRACE,\n  // Optional alternate timescale TLV\n  ALTERNATE_TIME_OFFSET_INDICATOR\n  // there are more, but not needed yet\n};\n\n// Table 23\nenum controlFieldValue {\n  Control_Field_Value_Sync,\n  Control_Field_Value_Delay_Req,\n  Control_Field_Value_Follow_Up,\n  Control_Field_Value_Delay_Resp,\n  Control_Field_Value_Management,\n  Control_Field_Value_Other\n};\n\n// this is the structure of a PATH_TRACE TLV (16.2, Table 78, pp 164) without any space for the data\nstruct __attribute__((__packed__)) ptp_path_trace_tlv {\n  uint16_t tlvType;\n  uint16_t lengthField;\n  uint8_t pathSequence[0];\n};\n\n// this is the structure of a TLV (14.3, Table 35, pp 135) without any space for the data\nstruct __attribute__((__packed__)) ptp_tlv {\n  uint16_t tlvType;\n  uint16_t lengthField;\n  uint8_t organizationId[3];\n  uint8_t organizationSubType[3];\n  uint8_t dataField[0];\n};\n\n// this is the Common Message Header\nstruct __attribute__((__packed__)) ptp_common_message_header {\n  uint8_t transportSpecificAndMessageID; // 0x11\n  uint8_t reservedAndVersionPTP;         // 0x02\n  uint16_t messageLength;\n  uint8_t domainNumber;     // 0\n  uint8_t reserved_b;       // 0\n  uint16_t flags;           // 0x0608\n  uint64_t correctionField; // 0\n  uint32_t reserved_l;      // 0\n  uint8_t clockIdentity[8]; // MAC\n  uint16_t sourcePortID;    // 1\n  uint16_t sequenceId;      // increments\n  uint8_t controlField;     // 5\n  uint8_t logMessagePeriod; // 0\n};\n\n// this is the extra part for an Announce message\nstruct __attribute__((__packed__)) ptp_announce {\n  uint8_t originTimestamp[10];\n  uint16_t currentUtcOffset;\n  uint8_t reserved1;\n  uint8_t grandmasterPriority1;\n  uint32_t grandmasterClockQuality;\n  uint8_t grandmasterPriority2;\n  uint8_t grandmasterIdentity[8];\n  uint16_t stepsRemoved;\n  uint8_t timeSource;\n  struct ptp_path_trace_tlv path_trace[0];\n};\n\n// this is the extra part for a Sync or Delay_Req message\nstruct __attribute__((__packed__)) ptp_sync {\n  uint8_t originTimestamp[10];\n};\n\n// this is the extra part for a Sync or Delay_Req message\nstruct __attribute__((__packed__)) ptp_delay_req {\n  uint8_t originTimestamp[10];\n};\n\n// this is the extra part for a Follow_Up message\nstruct __attribute__((__packed__)) ptp_follow_up {\n  uint8_t preciseOriginTimestamp[10];\n  // to be followed by zero or more TLVs\n  struct ptp_tlv tlvs[0];\n};\n\n// this is the extra part for a Delay_Resp message\nstruct __attribute__((__packed__)) ptp_delay_resp {\n  uint8_t receiveTimestamp[10];\n  uint8_t requestingPortIdentity[10];\n};\n\n// this is the extra part for a Pdelay_Req message (13.9, pp 131)\nstruct __attribute__((__packed__)) ptp_pdelay_req {\n  uint8_t originTimestamp[10];\n  uint8_t reserved[10]; // to make it the same length as a Pdelay_Resp message\n};\n\n// this is the extra part for a Pdelay_Resp message (13.10, pp 131)\nstruct __attribute__((__packed__)) ptp_pdelay_resp {\n  uint8_t requestReceiptTimestamp[10];\n  uint8_t requestingPortIdentity[10];\n};\n\n// this is the extra part for a Signaling message (13.12, pp 132) without any TLVs\nstruct __attribute__((__packed__)) ptp_signaling {\n  uint8_t targetPortIdentity[10];\n  // to be followed by _one_ or more TLVs\n  struct ptp_tlv tlvs[0];\n};\n\nstruct __attribute__((__packed__)) ptp_pdelay_req_message {\n  struct ptp_common_message_header header;\n  struct ptp_pdelay_req pdelay_req;\n};\n\nstruct __attribute__((__packed__)) ptp_pdelay_resp_message {\n  struct ptp_common_message_header header;\n  struct ptp_pdelay_resp pdelay_resp;\n};\n\nstruct __attribute__((__packed__)) ptp_sync_message {\n  struct ptp_common_message_header header;\n  struct ptp_sync sync;\n};\n\nstruct __attribute__((__packed__)) ptp_delay_req_message {\n  struct ptp_common_message_header header;\n  struct ptp_delay_req delay_req;\n};\n\nstruct __attribute__((__packed__)) ptp_follow_up_message {\n  struct ptp_common_message_header header;\n  struct ptp_follow_up follow_up;\n};\n\nstruct __attribute__((__packed__)) ptp_delay_resp_message {\n  struct ptp_common_message_header header;\n  struct ptp_delay_resp delay_resp;\n};\n\nstruct __attribute__((__packed__)) ptp_announce_message {\n  struct ptp_common_message_header header;\n  struct ptp_announce announce;\n};\n\nstruct __attribute__((__packed__)) ptp_signaling_message {\n  struct ptp_common_message_header header;\n  struct ptp_signaling signaling;\n};\n\n#endif\n<><><>CONTENTS OF nqptp-message-handlers.c:<><><>\n/*\n * This file is part of the nqptp distribution (https://github.com/mikebrady/nqptp).\n * Copyright (c) 2021-2022 Mike Brady.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n * Commercial licensing is also available.\n */\n#include <arpa/inet.h> // ntohl and ntohs\n#include <string.h>    //strsep\n\n#include <stdio.h>  // snprintf\n#include <stdlib.h> // drand48\n#include <unistd.h> // usleep\n\n#include \"debug.h\"\n#include \"general-utilities.h\"\n#include \"nqptp-message-handlers.h\"\n#include \"nqptp-ptp-definitions.h\"\n#include \"nqptp-utilities.h\"\n\nchar hexcharbuffer[16384];\nint reset_clock_smoothing = 0;\nuint64_t clock_validity_expiration_time = 0;\nint clock_is_active = 0;\n\nchar *hex_string(void *buf, size_t buf_len) {\n  char *tbuf = (char *)buf;\n  char *obfp = hexcharbuffer;\n  size_t obfc;\n  for (obfc = 0; obfc < buf_len; obfc++) {\n    snprintf(obfp, 3, \"%02X\", *tbuf);\n    obfp += 2;\n    tbuf = tbuf + 1;\n  };\n  *obfp = 0;\n  return hexcharbuffer;\n}\n\nvoid handle_control_port_messages(char *buf, ssize_t recv_len,\n                                  clock_source_private_data *clock_private_info,\n                                  uint64_t reception_time) {\n  if (recv_len != -1) {\n    buf[recv_len - 1] = 0; // make sure there's a null in it!\n    debug(2, \"New control port message: \\\"%s\\\".\", buf);\n    // we need to get the client shared memory interface name from the front\n    char *ip_list = buf;\n    char *smi_name = strsep(&ip_list, \" \");\n    char *command = NULL;\n    if (smi_name != NULL) {\n      if (ip_list != NULL)\n        command = strsep(&ip_list, \" \");\n\n      // \"B\" is for play begin/resume. Assumes a \"T <ip>\" already\n      // \"E\" is for play end/stop.\n      // \"P\" is for pause (currently Buffered Audio only).\n      //\n      // \"T <ip>\" is for the IP address of a timer.\n      // \"T\" means no active timer.\n      // clock_is_active is made true by Play and false by Pause or End.\n\n      if ((strcmp(command, \"B\") == 0) && (ip_list == NULL)) {\n        debug(2, \"Play.\");\n        // We want to avoid, as much as possible, resetting the clock smoothing.\n        // If we know the clock is already active or\n        // if it's only been a short time since we know it was last active\n        // then we will not reset the clock.\n        if (clock_is_active) {\n          debug(2, \"clock is already active\");\n        } else {\n          // Find out if the clock is active i.e. not sleeping.\n          // We know it is active between \"B\" and \"E\" commands.\n          // We also know it is active for brief periods after the \"T\" and \"E\" commands are\n          // received. If it is not definitely active, we will reset smoothing.\n          int will_ask_for_a_reset = 0;\n          if (clock_validity_expiration_time == 0) {\n            debug(1, \"no clock_validity_expiration_time.\");\n            will_ask_for_a_reset = 1;\n          } else {\n            int64_t time_to_clock_expiration = clock_validity_expiration_time - reception_time;\n            // timings obtained with an iPhone Xs Max on battery save\n\n            // around 30 seconds at a buffered audio pause on an iphone.\n            // around 1 second after a buffered audio stop on an iphone\n            // 10 seconds after a \"T\" from an iPhone that immediately sleeps\n            // more than a minute from \"T\" from a HomePod mini.\n\n            if (time_to_clock_expiration < 0) {\n              debug(2, \"Clock validity may have expired, so ask for a reset.\");\n              will_ask_for_a_reset = 1;\n            }\n          }\n          if (will_ask_for_a_reset != 0) {\n            debug(2, \"Reset clock smoothing\");\n            reset_clock_smoothing = 1;\n          }\n        }\n        clock_is_active = 1;\n        clock_validity_expiration_time = 0;\n      } else if ((strcmp(command, \"E\") == 0) && (ip_list == NULL)) {\n        debug(2, \"Stop\");\n        if (clock_is_active) {\n          debug(2, \"reset clock_validity_expiration_time to 2.25 seconds in the future.\");\n          clock_validity_expiration_time =\n              reception_time + 2250000000; // expiration time can be very soon after an \"E\"\n          clock_is_active = 0;\n        } else {\n          debug(2, \"clock is already inactive.\");\n        }\n      } else if ((strcmp(command, \"P\") == 0) && (ip_list == NULL)) {\n        debug(2, \"Pause\");\n        // A pause always seems to turn into a Stop in now more than a few seconds, and the clock\n        // keeps going, it seems so there is nothing to do here.\n      } else if ((command == NULL) || ((strcmp(command, \"T\") == 0) && (ip_list == NULL))) {\n        debug(2, \"Stop Timing\");\n        clock_is_active = 0;\n        debug(2, \"Clear timing peer group.\");\n        // dirty experimental hack -- delete all the clocks\n        int gc;\n        for (gc = 0; gc < MAX_CLOCKS; gc++) {\n          memset(&clock_private_info[gc], 0, sizeof(clock_source_private_data));\n        }\n        update_master_clock_info(0, NULL, 0, 0, 0); // the SMI may have obsolete stuff in it\n      } else {\n        debug(2, \"Start Timing\");\n        // dirty experimental hack -- delete all the clocks\n        int gc;\n        for (gc = 0; gc < MAX_CLOCKS; gc++) {\n          memset(&clock_private_info[gc], 0, sizeof(clock_source_private_data));\n        }\n        debug(2, \"get or create new record for \\\"%s\\\".\", smi_name);\n        //        client_id = get_client_id(smi_name); // create the record if it doesn't exist\n        //        if (client_id != -1) {\n        if (strcmp(command, \"T\") == 0) {\n          int i;\n          for (i = 0; i < MAX_CLOCKS; i++) {\n            clock_private_info[i].announcements_without_followups =\n                0; // to allow a possibly silent clock to be revisited when added to a timing\n                   // peer list\n            clock_private_info[i].follow_up_number = 0;\n          }\n\n          // take the first ip and make it the master, permanently\n\n          if (ip_list != NULL) {\n            char *new_ip = strsep(&ip_list, \" \");\n            // look for the IP in the list of clocks, and create an inert entry if not there\n            if ((new_ip != NULL) && (new_ip[0] != 0)) {\n              int t = find_clock_source_record(new_ip, clock_private_info);\n              if (t == -1)\n                t = create_clock_source_record(new_ip, clock_private_info);\n              if (t != -1) { // if the clock table is not full, okay\n                debug(2, \"Monitor clock at %s.\", new_ip);\n              }\n              // otherwise, drop it\n            }\n          }\n          // a new clock timing record will be started now\n          debug(2, \"reset clock_validity_expiration_time to 5.0 seconds in the future.\");\n          clock_validity_expiration_time =\n              reception_time + 5000000000L; // clock can stop as soon as 6 seconds after a \"T\"\n        } else {\n          warn(\"Unrecognised string on the control port.\");\n        }\n        //        } else {\n        //          warn(\"Could not find or create a record for SMI Interface \\\"%s\\\".\", smi_name);\n        //        }\n      }\n    } else {\n      warn(\"SMI Interface Name not found on the control port.\");\n    }\n  } else {\n    warn(\"Bad packet on the control port.\");\n  }\n}\n\nvoid handle_announce(char *buf, ssize_t recv_len, clock_source_private_data *clock_private_info,\n                     __attribute__((unused)) uint64_t reception_time) {\n  // debug_print_buffer(1, buf, (size_t) recv_len);\n  // make way for the new time\n  if ((size_t)recv_len >= sizeof(struct ptp_announce_message)) {\n    struct ptp_announce_message *msg = (struct ptp_announce_message *)buf;\n\n    uint64_t packet_clock_id = nctohl(&msg->header.clockIdentity[0]);\n    uint64_t packet_clock_id_low = nctohl(&msg->header.clockIdentity[4]);\n    packet_clock_id = packet_clock_id << 32;\n    packet_clock_id = packet_clock_id + packet_clock_id_low;\n    clock_private_info->clock_id = packet_clock_id;\n    clock_private_info->grandmasterPriority1 =\n        msg->announce.grandmasterPriority1; // need this for possibly pinging it later...\n    clock_private_info->grandmasterPriority2 =\n        msg->announce.grandmasterPriority2; // need this for possibly pinging it later...\n\n    debug(2, \"announcement seen from %\" PRIx64 \" at %s.\", clock_private_info->clock_id,\n          clock_private_info->ip);\n\n    if (clock_private_info->announcements_without_followups < 5) // don't keep going forever\n      // a value of 4 means it's parked --\n      // it has seen three, poked the clock and doesn't want to do any more.\n      clock_private_info->announcements_without_followups++;\n\n    uint64_t grandmaster_clock_id = nctohl(&msg->announce.grandmasterIdentity[0]);\n    uint64_t grandmaster_clock_id_low = nctohl(&msg->announce.grandmasterIdentity[4]);\n    grandmaster_clock_id = grandmaster_clock_id << 32;\n    grandmaster_clock_id = grandmaster_clock_id + grandmaster_clock_id_low;\n    uint32_t clockQuality = ntohl(msg->announce.grandmasterClockQuality);\n    uint8_t clockClass = (clockQuality >> 24) & 0xff;\n    uint8_t clockAccuracy = (clockQuality >> 16) & 0xff;\n    uint16_t offsetScaledLogVariance = clockQuality & 0xffff;\n    uint16_t stepsRemoved = ntohs(msg->announce.stepsRemoved);\n    uint16_t sourcePortID = ntohs(msg->header.sourcePortID);\n\n    clock_private_info->grandmasterIdentity = grandmaster_clock_id;\n    clock_private_info->grandmasterPriority1 = msg->announce.grandmasterPriority1;\n    clock_private_info->grandmasterQuality = clockQuality;\n    clock_private_info->grandmasterClass = clockClass;\n    clock_private_info->grandmasterAccuracy = clockAccuracy;\n    clock_private_info->grandmasterVariance = offsetScaledLogVariance;\n    clock_private_info->grandmasterPriority2 = msg->announce.grandmasterPriority2;\n    clock_private_info->stepsRemoved = stepsRemoved;\n    clock_private_info->clock_port_number = sourcePortID;\n\n    if (clock_private_info->wakeup_sent == 0) {\n      send_awakening_announcement_sequence(\n          clock_private_info->clock_id, clock_private_info->ip, clock_private_info->family,\n          clock_private_info->grandmasterPriority1, clock_private_info->grandmasterPriority2);\n      clock_private_info->wakeup_sent = 1;\n    }\n  }\n}\n\nvoid handle_sync(char *buf, ssize_t recv_len, clock_source_private_data *clock_private_info,\n                 __attribute__((unused)) uint64_t reception_time) {\n  /*\n    // diagnostic -- decide whether to delay the processing of the follow_up to simulate a noisy\n    network if (drand48() < 0.015) {\n      // generate a random delay between 10 and 3500 milliseconds\n      int delay = (int)((3000 - 60) * drand48()) + 60;\n      debug(1,\"Delay sync processing by %u milliseconds.\", delay);\n      usleep(delay * 1000);\n      reception_time = get_time_now();\n    }\n  */\n\n  if (clock_private_info->clock_id == 0) {\n    debug(2, \"Sync received before announcement -- discarded.\");\n  } else {\n    if ((recv_len >= 0) && ((size_t)recv_len >= sizeof(struct ptp_sync_message))) {\n      // debug_print_buffer(1, buf, recv_len);\n      struct ptp_sync_message *msg = (struct ptp_sync_message *)buf;\n\n      // clang-format off\n      \n      // actually the precision timestamp needs to be corrected by the Follow_Up Correction_Field contents.\n      // According to IEEE Std 802.1AS-2020, paragraph 11.4.4.2.1:\n      /*\n      The value of the preciseOriginTimestamp field is the sourceTime of the ClockMaster entity of the Grandmaster PTP Instance,\n      when the associated Sync message was sent by that Grandmaster PTP Instance, with any fractional nanoseconds truncated (see 10.2.9).\n      The sum of the correctionFields in the Follow_Up and associated Sync messages, added to the preciseOriginTimestamp field of the Follow_Up message,\n      is the value of the synchronized time corresponding to the syncEventEgressTimestamp at the PTP Instance that sent the associated Sync message,\n      including any fractional nanoseconds.\n      */\n\n      // clang-format on\n\n      int64_t correction_field = ntoh64(msg->header.correctionField);\n\n      if (correction_field != 0)\n        debug(1, \"Sync correction field is non-zero: %\" PRId64 \" ns.\", correction_field);\n\n      correction_field = correction_field / 65536; // might be signed\n    } else {\n      debug(1, \"Sync message is too small to be valid.\");\n    }\n  }\n}\n\nvoid handle_follow_up(char *buf, ssize_t recv_len, clock_source_private_data *clock_private_info,\n                      uint64_t reception_time) {\n  if (clock_private_info->clock_id == 0) {\n    debug(2, \"Follow_Up received before announcement -- discarded.\");\n  } else {\n    clock_private_info->announcements_without_followups = 0;\n    if ((recv_len >= 0) && ((size_t)recv_len >= sizeof(struct ptp_follow_up_message))) {\n      // debug_print_buffer(1, buf, recv_len);\n      struct ptp_follow_up_message *msg = (struct ptp_follow_up_message *)buf;\n      uint16_t seconds_hi = nctohs(&msg->follow_up.preciseOriginTimestamp[0]);\n      uint32_t seconds_low = nctohl(&msg->follow_up.preciseOriginTimestamp[2]);\n      uint32_t nanoseconds = nctohl(&msg->follow_up.preciseOriginTimestamp[6]);\n      uint64_t preciseOriginTimestamp = seconds_hi;\n      preciseOriginTimestamp = preciseOriginTimestamp << 32;\n      preciseOriginTimestamp = preciseOriginTimestamp + seconds_low;\n      preciseOriginTimestamp = preciseOriginTimestamp * 1000000000L;\n      preciseOriginTimestamp = preciseOriginTimestamp + nanoseconds;\n\n      // update our sample information\n      int grandmasterClockIsStopped = 0;\n      if ((clock_private_info->previous_preciseOriginTimestamp == preciseOriginTimestamp) &&\n          (clock_private_info->clock_id == clock_private_info->grandmasterIdentity)) {\n        clock_private_info->identical_previous_preciseOriginTimestamp_count++;\n        grandmasterClockIsStopped = 1;\n        if (clock_private_info->identical_previous_preciseOriginTimestamp_count == 8 * 60) {\n          int64_t duration_of_mastership =\n              reception_time - clock_private_info->mastership_start_time;\n          if (clock_private_info->mastership_start_time == 0)\n            duration_of_mastership = 0;\n          debug(2,\n                \"Clock %\" PRIx64 \"'s grandmaster clock has stopped after %f seconds of mastership.\",\n                clock_private_info->clock_id, 0.000000001 * duration_of_mastership);\n          int64_t wait_limit = 62;\n          wait_limit = wait_limit * 1000000000;\n          // only try to restart a grandmaster clock on the clock itself.\n          if ((duration_of_mastership <= wait_limit) &&\n              (clock_private_info->clock_id == clock_private_info->grandmasterIdentity)) {\n            debug(2,\n                  \"Attempt to start a stopped clock %\" PRIx64 \", at follow_up_number %u at IP %s.\",\n                  clock_private_info->clock_id, clock_private_info->follow_up_number,\n                  clock_private_info->ip);\n            send_awakening_announcement_sequence(\n                clock_private_info->clock_id, clock_private_info->ip, clock_private_info->family,\n                clock_private_info->grandmasterPriority1, clock_private_info->grandmasterPriority2);\n          }\n        }\n      } else {\n        clock_private_info->identical_previous_preciseOriginTimestamp_count = 0;\n      }\n\n      clock_private_info->previous_preciseOriginTimestamp = preciseOriginTimestamp;\n\n      // clang-format off\n      \n      // actually the precision timestamp needs to be corrected by the Follow_Up Correction_Field contents.\n      // According to IEEE Std 802.1AS-2020, paragraph 11.4.4.2.1:\n      /*\n      The value of the preciseOriginTimestamp field is the sourceTime of the ClockMaster entity of the Grandmaster PTP Instance,\n      when the associated Sync message was sent by that Grandmaster PTP Instance, with any fractional nanoseconds truncated (see 10.2.9).\n      The sum of the correctionFields in the Follow_Up and associated Sync messages, added to the preciseOriginTimestamp field of the Follow_Up message,\n      is the value of the synchronized time corresponding to the syncEventEgressTimestamp at the PTP Instance that sent the associated Sync message,\n      including any fractional nanoseconds.\n      */\n\n      // clang-format",
      "date": "2024-06-12T13:20:36.973223",
      "usage": {
        "prompt_tokens": 26732,
        "completion_tokens": 6849,
        "cost": 0.029549375000000003
      }
    }
  ],
  "leads": [
    {
      "headline": "Potential race condition in handling of shared memory",
      "analysis": "The code uses a shared memory interface to communicate between the main thread and a broadcasting task. However, there is no explicit synchronization mechanism to protect access to the shared memory during the execution of timed tasks. This could lead to a race condition if a timed task and the main thread try to access or modify the shared memory simultaneously. For example, the broadcasting task might read an inconsistent state if the main thread is in the middle of updating it.\n\nAn attacker could potentially exploit this race condition by sending a carefully timed sequence of PTP messages and control port messages, causing the broadcasting task to read incorrect clock information. This could lead to denial of service if the incorrect information disrupts the synchronization of the PTP clocks.\n",
      "classification": "slightly promising",
      "cwe": "CWE-362",
      "function_names": [
        "broadcasting_task",
        "handle_control_port_messages"
      ],
      "filenames": [
        "nqptp.c",
        "nqptp-clock-sources.c"
      ]
    }
  ],
  "scores": [
    {
      "stats": {
        "fn": 1,
        "tp": 0,
        "fp": 0
      },
      "mapping": {},
      "vuln_dates": {
        "CVE-2023-43771": "2023-09-22T06:15:10"
      },
      "scoring_model": "claude-3-opus-20240229",
      "type": "llm",
      "instruction_template_hash": "245ace12b6361954d0a2"
    },
    {
      "stats": {
        "fn": 1,
        "tp": 0,
        "fp": 0
      },
      "mapping": {},
      "vuln_dates": {
        "CVE-2023-43771": "2023-09-22T06:15:10"
      },
      "scoring_model": "claude-3-5-sonnet-20240620",
      "type": "llm",
      "instruction_template_hash": "245ace12b6361954d0a2"
    }
  ],
  "instruction_template_hash": "10c0163db4740318a544",
  "version": "0.1.0"
}
